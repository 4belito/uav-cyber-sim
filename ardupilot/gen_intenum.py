"""
Generate Enum source file for ArduPilot-style parameter values as IntEnum members.

This script parses a local ArduPilot parameter definition file (`apm.pdef.json`),
extracts enum-style parameter dictionaries (like `FRAME_CLASS`), and generates an
`IntEnum` class into the `enums/` folder.

It is intended for occasional, developer-triggered use—typically after updating
ArduPilot parameter definitions—rather than regular execution.

Run from the repo root:

    python -m ardupilot.gen_intenum

This ensures proper imports like:
    from helpers.codegen import write_init_file

Avoid running directly (e.g., `python gen_intenum.py`), as it may break imports.
"""

import json
import os
import re

from ardupilot.enums.__init__ import __all__ as current_imports
from helpers.codegen import make_docstring, write_init_file

BASE_DIR = os.path.dirname(__file__)
PARAM_PATH = os.path.join(BASE_DIR, "copter_params/apm.pdef.json")

manual_imports: list[
    str
] = []  # Add any manually written enums to be included in __init__.py

with open(PARAM_PATH, "r") as f:
    param_data = json.load(f)

PARAM_DEFS = [
    {
        "component": "Copter",
        "name": "FrameClass",
        "param": "FRAME_CLASS",
    },
    {
        "component": "Copter",
        "name": "FrameType",
        "param": "FRAME_TYPE",
    },
    {
        "component": "BRD_",
        "name": "BRDType",
        "param": "BRD_TYPE",
    },
    {
        "component": "MOT_",
        "name": "MOTPWMType",
        "param": "MOT_PWM_TYPE",
    },
]


def sanitize_identifier(name: str) -> str:
    """Sanitize a string to be a valid Python identifier."""
    sanitized = re.sub(r"\W|^(?=\d)", "_", name)
    return sanitized if sanitized.isidentifier() else f"_{sanitized}"


def generate_int_enum(enum_name: str, values: dict[str, str], description: str) -> str:
    """
    Generate the source code string for an IntEnum
    class based on parameter values.
    """
    lines = [
        f"{make_docstring(description, indent=0)}",
        "",
        "from enum import IntEnum",
        "",
        "",
        f"class {enum_name}(IntEnum):",
        make_docstring(
            description + f"\nAutogenerated from in file {PARAM_PATH}.",
            indent=4,
        ),
        "",
    ]
    for k, v in values.items():
        try:
            val = int(k)
        except ValueError:
            continue
        name = sanitize_identifier(v)
        lines.append(f"    {name} = {val}")
    return "\n".join(lines) + "\n"


def write_int_enum_file(
    name: str, values: dict[str, str], outfile: str, description: str
):
    """Write an IntEnum class to the specified output file."""
    code = generate_int_enum(name, values, description)
    os.makedirs(os.path.dirname(outfile), exist_ok=True)
    with open(outfile, "w") as f:
        f.write(code)
    print(f"\u2705 IntEnum written to {outfile}")


if __name__ == "__main__":
    ENUM_DIR = os.path.join(BASE_DIR, "enums")
    for param in PARAM_DEFS:
        enum_name = param["name"]
        outfile = os.path.join(ENUM_DIR, f"{enum_name.lower()}.py")
        values = param_data[param["component"]][param["param"]]["Values"]
        description = param_data[param["component"]][param["param"]]["Description"]
        write_int_enum_file(enum_name, values, outfile, description)

    write_init_file(ENUM_DIR, [p["name"] for p in PARAM_DEFS] + current_imports)
