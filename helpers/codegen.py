"""General Tools for code generation."""

import os
import textwrap


def write_init_file(module_dir: str, class_names: list[str]):
    """Generate __init__.py to imports all classes and sets __all__, alphabetically."""
    class_names = sorted(set(class_names))  # Alphabetical order

    lines = [
        '"""Init file for enums package."""',
        "",
    ]
    for name in class_names:
        lines.append(f"from .{name.lower()} import {name}")
    lines.append("")
    lines.append("__all__ = [")
    for name in class_names:
        lines.append(f'    "{name}",')
    lines.append("]")

    init_path = os.path.join(module_dir, "__init__.py")
    with open(init_path, "w") as f:
        f.write("\n".join(lines))
    print(f"âœ… __init__.py written to {init_path}")


def make_docstring(text: str, indent: int = 4, width: int = 80) -> str:
    """
    Format a Python docstring with correct punctuation, wrapping,
    and Ruff D200 compliance.
    """
    text = "Autogenerated. " + text.strip()
    if text and not text.endswith((".", "!", "?")):
        text += "."

    indent_str = " " * indent
    max_inline_len = width - (indent + 6)  # 6 = len('""" """')

    if len(text) <= max_inline_len and "\n" not in text:
        # One-line inline docstring
        return f'{indent_str}"""{text}"""'
    else:
        # Wrapped multi-line docstring
        wrapper = textwrap.TextWrapper(
            width=width - indent,
            initial_indent=indent_str,
            subsequent_indent=indent_str,
        )
        wrapped = wrapper.fill(text)
        return f'{indent_str}"""\n{wrapped}\n{indent_str}"""'
